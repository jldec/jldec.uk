<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="x-ua-compatible" content="ie=edge">

<meta property="og:title" content="Getting started with Goroutines and channels">
<meta property="og:image" content="https://jldec.me/images/grape-hyacinth.jpg">
<meta property="og:type" content="article">
<meta property="og:url" content="https://jldec.me/getting-started-with-go-part-3-goroutines-and-channels">
<meta property="og:description" content="My experience as a new user of Goroutines and channels">
<meta name="twitter:site" content="@jldec">
<meta name="twitter:creator" content="@jldec">
<meta name="twitter:title" content="Getting started with Goroutines and channels">
<meta name="twitter:description" content="My experience as a new user of Goroutines and channels">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:widgets:new-embed-design" content="on">
<meta name="twitter:image" content="https://jldec.me/images/grape-hyacinth.jpg">
<meta name="twitter:image:alt" content="Ladybug in Cambridge UK">
<meta name="robots" content="noindex, nofollow">
<link rel="canonical" href="https://jldec.me/getting-started-with-go-part-3-goroutines-and-channels">

<!-- html generated by pub-server from markdown /getting-started-with-go-part-3-goroutines-and-channels.md -->

<title>Getting started with Goroutines and channels</title>
<link rel="stylesheet" href="./css/pubblog.css">
<link rel="stylesheet" href="./css/open-sans.css">
<link rel="stylesheet" href="./css/font-awesome.css">
<link rel="stylesheet" href="./css/highlight-11.4.0-github.css">
<!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>

<div data-render-layout="main-layout">
<header>
<div id="doctitle"><h1 id="jldecuk"><a href="./">jldec.uk</a></h1>
</div>
<div id="topmenu"><div data-render-html="/#topmenu">&nbsp;</div></div>
</header>

<div id="navicon" onclick=""><p><span class="fa fa-fw fa-2x">&#xf01a;</span></p>

<nav id="toc">
<ul>
<li><strong><a href="./">Home</a></strong></li>
<li><a href="./first-impressions-of-the-new-github-projects-beta">First impressions of the new GitHub Projects Beta</a></li>
<li><a href="./using-gitpod-to-create-a-pr">Using Gitpod to create a PR</a></li>
<li><a href="./preventing-concurrent-github-actions">Preventing concurrent GitHub Actions</a></li>
<li><a href="./getting-started-with-go-part-3-goroutines-and-channels">Getting started with Goroutines and channels</a></li>
<li><a href="./getting-started-with-go-part-2-pointers">Getting started with Go pointers</a></li>
<li><a href="./getting-started-with-go">Getting started with Go</a></li>
<li><a href="./extracting-an-esm-module-from-a-deno-script">Extracting an ESM module from a Deno script</a></li>
<li><a href="./running-a-compiled-deno-script-in-a-github-action">Running a compiled Deno script in a GitHub Action</a></li>
<li><a href="./getting-started-with-deno">Getting Started with Deno</a></li>
<li><a href="./calling-rust-from-a-cloudflare-worker">Calling Rust from a Cloudflare Worker</a></li>
<li><a href="./fun-with-vercel">Fun with Vercel</a></li>
<li><a href="./first-steps-using-cloudflare-pages">First steps using Cloudflare Pages</a></li>
<li><a href="./migrating-from-cjs-to-esm">Migrating from CommonJS to ESM</a></li>
<li><a href="./forays-from-node-to-rust">Forays from Node to Rust</a></li>
<li><a href="./github-actions-101">GitHub Actions 101</a></li>
<li><a href="./a-web-for-everyone">A Web for Everyone</a></li>
<li><a href="./why-serverless-at-the-edge">Why Serverless at the Edge?</a></li>
<li><a href="./spring-boot-101">Spring Boot 101</a></li>
<li><a href="./why-the-web-needs-better-html-editing-components">Why the Web needs better HTML editing components</a></li>
<li><a href="./about">About me</a></li>
</ul>
</nav>
</div>

<div id="title" style='background-image:url("images/grape-hyacinth.jpg");'>
  <div class="title">Getting started with Goroutines and channels</div>
  <div class="subtitle"></div>
</div>

<div id="main" onclick="">
<div id="content">

<div data-render-page="/getting-started-with-go-part-3-goroutines-and-channels">
<span class="permalink"><a class="permalink" href="./getting-started-with-go-part-3-goroutines-and-channels" title="Link to this post.">&#xf0c1;</a></span><span class="date">2021-04-25</span>

<div >
<div data-render-html="/getting-started-with-go-part-3-goroutines-and-channels"><h2 id="golang">Golang</h2>
<p>This is part 3 of my experience as a new user of Go, focusing on concurrency with Goroutines and channels.</p>
<p>For installation, testing, and packages, see <a href="./getting-started-with-go">Getting started with Go</a>, and for pointers see <a href="./getting-started-with-go-part-2-pointers">Getting started with Go pointers</a>.</p>
<h2 id="counting-http-requests">Counting HTTP requests</h2>
<p>The <a href="https://github.com/jldec/racey-go/blob/main/main.go" target="_blank" rel="noopener">server</a> below counts HTTP requests, and returns the latest count on each request. </p>
<p><em>To follow along, clone <a href="https://github.com/jldec/racey-go" target="_blank" rel="noopener">https://github.com/jldec/racey-go</a>, and start the server with &#39;go run .&#39;</em></p>
<pre><code class="language-go">package main

import (
    &quot;fmt&quot;
    &quot;net/http&quot;
)

func main() {
    var count uint64 = 0

    http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) {
        count++
        fmt.Fprintln(w, count)
    })

    fmt.Println(&quot;Go listening on port 3000&quot;)
    http.ListenAndServe(&quot;:3000&quot;, nil)
}
</code></pre>
<pre><code class="language-sh">$ curl localhost:3000
1
$ curl localhost:3000
2
</code></pre>
<p>Let&#39;s try sending multiple requests at the same time. This command invokes curl with urls from a file using xargs to spawn 4 processes at once.</p>
<pre><code class="language-sh">$ cat urls.txt | xargs -P 4 -n 1 curl
</code></pre>
<p>The <a href="https://github.com/jldec/racey-go/blob/main/urls.txt" target="_blank" rel="noopener">file</a> contains 100 lines, but instead of ending on a nice round number, on systems with more than 1 core you may see  something like this (e.g. after 3 runs)</p>
<pre><code>289
292
291
</code></pre>
<p>Replace the Go server with &#39;<a href="https://github.com/jldec/racey-go/blob/main/server.js" target="_blank" rel="noopener">node server.js</a>&#39; to compare the results (e.g. after 3 runs again)</p>
<pre><code>298
299
300
</code></pre>
<p>Now repeat the experiment with the <a href="https://golang.org/doc/articles/race_detector" target="_blank" rel="noopener">race detector</a> turned on. The detector will report a problem on <a href="https://github.com/jldec/racey-go/blob/main/main.go#L12" target="_blank" rel="noopener">line 12</a> of main.go which is <code>count++</code>.</p>
<pre><code class="language-sh">$ go run -race .
Go listening on port 3000
==================
WARNING: DATA RACE
Read at 0x00c000138280 by goroutine 7:
  main.main.func1()
      /Users/jleschner/pub/racey-go/main.go:12 +0x4a
  net/http.HandlerFunc.ServeHTTP()
      /Users/jleschner/go1.16.3/src/net/http/server.go:2069 +0x51
  net/http.(*ServeMux).ServeHTTP()
      /Users/jleschner/go1.16.3/src/net/http/server.go:2448 +0xaf
  net/http.serverHandler.ServeHTTP()
      /Users/jleschner/go1.16.3/src/net/http/server.go:2887 +0xca
  net/http.(*conn).serve()
      /Users/jleschner/go1.16.3/src/net/http/server.go:1952 +0x87d

Previous write at 0x00c000138280 by goroutine 9:
  main.main.func1()
      /Users/jleschner/pub/racey-go/main.go:12 +0x64
  net/http.HandlerFunc.ServeHTTP()
      /Users/jleschner/go1.16.3/src/net/http/server.go:2069 +0x51
  net/http.(*ServeMux).ServeHTTP()
      /Users/jleschner/go1.16.3/src/net/http/server.go:2448 +0xaf
  net/http.serverHandler.ServeHTTP()
      /Users/jleschner/go1.16.3/src/net/http/server.go:2887 +0xca
  net/http.(*conn).serve()
      /Users/jleschner/go1.16.3/src/net/http/server.go:1952 +0x87d
</code></pre>
<h2 id="data-races">Data races</h2>
<p>From the <a href="https://golang.org/doc/articles/race_detector" target="_blank" rel="noopener">race detector</a> docs:</p>
<p><em>A data race occurs when two goroutines access the same variable concurrently and at least one of the accesses is a write.</em></p>
<blockquote>
<p>It&#39;s clear that &#39;count++&#39; modifies the count, but what are goroutines and where are they in this case?</p>
</blockquote>
<h2 id="goroutines">Goroutines</h2>
<p>Goroutines provide low-overhead threading. They are easy to create and scale well on multi-core processors.</p>
<p>The Go runtime can schedule many concurrent goroutines across a small number of OS threads. Under the covers, this is how the <a href="https://golang.org/src/net/http/server.go#L3013" target="_blank" rel="noopener">http</a> library handles concurrent web requests.</p>
<p>Let&#39;s start with an example. You can run it in the <a href="https://play.golang.org/p/HdH4UQEEXuU" target="_blank" rel="noopener">Go Playground</a>.</p>
<pre><code class="language-go">package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func main() {
    ch := make(chan string)

    // start 2 countdowns in parallel goroutines
    go countdown(&quot;crew-1&quot;, ch)
    go countdown(&quot;crew-2&quot;, ch)

    fmt.Println(&lt;-ch) // block waiting to receive 1st string
    fmt.Println(&lt;-ch) // block waiting to receive 2nd string
}

func countdown(name string, ch chan&lt;- string) {
    for i := 10; i &gt; 0; i-- {
        fmt.Println(name, i)
        time.Sleep(1 * time.Second)
    }
    ch &lt;- &quot;blastoff &quot; + name
}
</code></pre>
<p>Each &#39;go countdown()&#39; starts a new <a href="https://tour.golang.org/concurrency/1" target="_blank" rel="noopener">goroutine</a>. Notice how the countdowns are interleaved in the output.</p>
<pre><code>...
crew-1 3
crew-2 3
crew-2 2
crew-1 2
crew-1 1
crew-2 1
blastoff crew-2
blastoff crew-1
</code></pre>
<h2 id="channels">Channels</h2>
<p><a href="https://tour.golang.org/concurrency/2" target="_blank" rel="noopener">Channels</a> allow goroutines to communicate and coordinate.</p>
<p>In the example above, <code>&lt;-ch</code> (receive) will block until another goroutine uses <code>ch &lt;-</code> to send a string to the channel. This happens at the end of each countdown.</p>
<p>Sends will also block if there are no receivers, but that is not the case here.</p>
<p>There are many other variations for how to use channels, including <a href="https://tour.golang.org/concurrency/3" target="_blank" rel="noopener">buffered channels</a> which only block sends when the buffer is full.</p>
<h2 id="atomicity">Atomicity</h2>
<p>Given that <a href="https://pkg.go.dev/net/http" target="_blank" rel="noopener">net/http</a> requests are handled by goroutines, can we explain why there is a data race when the function which handles a request increments a shared counter?</p>
<p>The reason is that <code>count++</code> requires a read followed by write, and these are not automatically synchronized. One goroutine may overwrite the increment of another, resulting in lost writes.</p>
<p>To fix this, the counter has be protected to make the increment operation atomic.</p>
<h2 id="counter-go">Counter-go</h2>
<p><a href="https://github.com/jldec/counter-go" target="_blank" rel="noopener">github.com/jldec/counter-go</a> demonstrates 3 different implementations of a threadsafe global counter.</p>
<ol>
<li><strong>CounterAtomic</strong> uses <code>atomic.AddUint64</code> and <code>atomic.LoadUint64</code>.</li>
<li><strong>CounterMutex</strong> uses <code>sync.RWMutex</code>.</li>
<li><strong>CounterChannel</strong> serializes all reads and writes inside 1 goroutine with 2 channels.</li>
</ol>
<p>All 3 types implement a Counter interface:</p>
<pre><code class="language-go">type Counter interface {
    Get() uint32 // get current counter value
    Inc()        // increment by 1
}
</code></pre>
<p>The <a href="https://github.com/jldec/racey-go/blob/fix-with-counter-go/main.go" target="_blank" rel="noopener">modified server</a> will work with any of the 3 implementations, and no data race should be detected.</p>
<pre><code class="language-go">package main

import (
    &quot;fmt&quot;
    &quot;net/http&quot;

    counter &quot;github.com/jldec/counter-go&quot;
)

func main() {
    count := new(counter.CounterAtomic)
    // count := new(counter.CounterMutex)
    // count := counter.NewCounterChannel()

    http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) {
        count.Inc()
        fmt.Fprintln(w, count.Get())
    })

    fmt.Println(&quot;Go listening on port 3000&quot;)
    http.ListenAndServe(&quot;:3000&quot;, nil)
}
</code></pre>
<h3 id="coordination-with-channels">Coordination with channels</h3>
<p>Of the 3 implementations, <a href="https://github.com/jldec/counter-go/blob/main/counter_channel.go" target="_blank" rel="noopener">CounterChannel</a> is the most interesting. All access to the counter goes through 1 goroutine which uses a <a href="https://tour.golang.org/concurrency/5" target="_blank" rel="noopener">select</a> to wait for either a read or a write on one of two channels.</p>
<p>Can you tell why neither <code>Inc()</code> nor <code>Get()</code> should block?</p>
<pre><code class="language-go">
package counter

// Thread-safe counter
// Uses 2 Channels to coordinate reads and writes.
// Must be initialized with NewCounterChannel().
type CounterChannel struct {
    readCh  chan uint64
    writeCh chan int
}

// NewCounterChannel() is required to initialize a Counter.
func NewCounterChannel() *CounterChannel {
    c := &amp;CounterChannel{
        readCh:  make(chan uint64),
        writeCh: make(chan int),
    }

    // The actual counter value lives inside this goroutine.
    // It can only be accessed for R/W via one of the channels.
    go func() {
        var count uint64 = 0
        for {
            select {
            // Reading from readCh is equivalent to reading count.
            case c.readCh &lt;- count:
            // Writing to the writeCh increments count.
            case &lt;-c.writeCh:
                count++
            }
        }
    }()

    return c
}

// Increment counter by pushing an arbitrary int to the write channel.
func (c *CounterChannel) Inc() {
    c.check()
    c.writeCh &lt;- 1
}

// Get current counter value from the read channel.
func (c *CounterChannel) Get() uint64 {
    c.check()
    return &lt;-c.readCh
}

func (c *CounterChannel) check() {
    if c.readCh == nil {
        panic(&quot;Uninitialized Counter, requires NewCounterChannel()&quot;)
    }
}
</code></pre>
<h3 id="benchmarks">Benchmarks</h3>
<p>All 3 <a href="https://github.com/jldec/counter-go" target="_blank" rel="noopener">implementations</a> are fast. Serializing everything through a goroutine with channels, costs only a few hundred ns for a single read or write. When constrained to a single OS thread, the cost of goroutines is even lower.</p>
<pre><code class="language-sh">$ go test -bench .
goos: darwin
goarch: amd64
pkg: github.com/jldec/counter-go
cpu: Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz
</code></pre>
<h4 id="simple-1-op--1-inc-in-same-thread">Simple: 1 op = 1 Inc() in same thread</h4>
<pre><code class="language-sh">BenchmarkCounter_1/Atomic-12                 195965660          6 ns/op
BenchmarkCounter_1/Mutex-12                   54177086         22 ns/op
BenchmarkCounter_1/Channel-12                  4499144        286 ns/op
</code></pre>
<h4 id="concurrent-1-op--1-inc-across-each-of-10-goroutines">Concurrent: 1 op = 1 Inc() across each of 10 goroutines</h4>
<pre><code class="language-sh">BenchmarkCounter_2/Atomic_no_reads-12          7298484        191 ns/op
BenchmarkCounter_2/Mutex_no_reads-12           1966656        621 ns/op
BenchmarkCounter_2/Channel_no_reads-12          256842       4771 ns/op
</code></pre>
<h4 id="concurrent-1-op---1-inc--10-get--across-each-of-10-goroutines">Concurrent: 1 op = [ 1 Inc() + 10 Get() ] across each of 10 goroutines</h4>
<pre><code class="language-sh">BenchmarkCounter_2/Atomic_10_reads-12          3922029        286 ns/op
BenchmarkCounter_2/Mutex_10_reads-12            416354       2844 ns/op
BenchmarkCounter_2/Channel_10_reads-12           21506      55733 ns/op
</code></pre>
<h4 id="constrained-to-single-thread">Constrained to single thread</h4>
<pre><code class="language-sh">$ GOMAXPROCS=1 go test -bench .

BenchmarkCounter_1/Atomic                    197135869          6 ns/op
BenchmarkCounter_1/Mutex                      55698454         22 ns/op
BenchmarkCounter_1/Channel                     5689788        214 ns/op

BenchmarkCounter_2/Atomic_no_reads            19519166         60 ns/op
BenchmarkCounter_2/Mutex_no_reads              4702759        254 ns/op
BenchmarkCounter_2/Channel_no_reads             530554       2197 ns/op

BenchmarkCounter_2/Atomic_10_reads             6269979        189 ns/op
BenchmarkCounter_2/Mutex_10_reads               927439       1354 ns/op
BenchmarkCounter_2/Channel_10_reads              47889      25054 ns/op
</code></pre>
<blockquote>
<p>🚀 - code safe - 🚀</p>
</blockquote>
<p><em>To leave a comment<br>please visit <a href="https://dev.to/jldec/getting-started-with-goroutines-and-channels-fc6" target="_blank" rel="noopener">dev.to/jldec</a></em></p>
</div>
</div>


</div><!--page-->

<div id="credit"><p><span class="fa">&#xf004;</span> powered by <a href="https://jldec.github.io/pub-doc/" target="_blank" rel="noopener">pub-server</a> and <a href="https://github.com/jldec/pub-theme-pubblog" target="_blank" rel="noopener">pub-theme-pubblog</a></p>
</div>

</div>
</div>

</div><!--layout-->

<script>window.pubRef = {"href":"/getting-started-with-go-part-3-goroutines-and-channels","relPath":"."};</script>
<script src="./js/jquery-1.12.4.min.js" ></script>
<script src="./js/highlight-11.4.0.min.js" ></script>
<script src="./js/pub-pkg-highlight.js" ></script>
<script src="./pub/pub-ux.js" ></script>
<!-- copyright -->
</body>
</html>
